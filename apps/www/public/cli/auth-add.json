{
  "$schema": "http://localhost:3000/cli/schema.json",
  "description": "Initialize Lucia with Drizzle ORM",
  "title": "Lucia init",
  "version": 1.0,
  "operation": [
    {
      "op": "select",
      "title": "Select your auth type to add",
      "selections": [
        {"label": "Password", "value": "password"},
        {"label": "Google", "value": "google"},
        {"label": "Github", "value": "github"},
        {"label": "Discord", "value": "discord"}
      ],
      "value": "$authAdd",
      "values": {
        "password": [
          {
            "op": "add",
            "content": "import { generateIdFromEntropySize } from \"lucia\";\nimport { hash, verify } from \"@node-rs/argon2\";\nimport { eq } from \"drizzle-orm\";\nimport z from 'zod'\n\nimport { lucia, userTable } from \"~/auth\";\nimport { db } from \"~/db\"\n\nconst signUpSchema = z.object({\n    email: z.string().email('Must be an email.'),\n    password: z.string().min(8),\n});\n\nexport async function passwordSignUp(request: Request) {\n    const body = await request.json();\n    const result = signUpSchema.safeParse(body);\n    if (!result.success) {\n        return new Response(result.error.message, { status: 400 });\n    }\n    const email = result.data.email;\n    const password = result.data.password;\n\n    const passwordHash = await hash(password, {\n        memoryCost: 19456,\n        timeCost: 2,\n        outputLen: 32,\n        parallelism: 1\n    });\n    const userId = generateIdFromEntropySize(10); // 16 characters long\n\n    try {\n        await db.insert(userTable).values({\n            id: userId,\n            username: email,\n            passwordHash\n        })\n\n        const session = await lucia.createSession(userId, {});\n        const sessionCookie = lucia.createSessionCookie(session.id);\n        return new Response(null, {\n            status: 302,\n            headers: {\n                Location: \"/\",\n                \"Set-Cookie\": sessionCookie.serialize()\n            }\n        });\n    } catch {\n        return new Response(\"Email already used\", {\n            status: 400\n        });\n    }\n}\n\nexport async function passwordSignIn(request: Request) {\n    const body = await request.json();\n    const result = signUpSchema.safeParse(body);\n    if (!result.success) {\n        return new Response(result.error.message, { status: 400 });\n    }\n    const email = result.data.email;\n    const password = result.data.password;\n\n    const dbUser = await db.select().from(userTable).where(eq(userTable.username, email))\n    const user = dbUser[0]\n\n\n    if (!user) {\n        // NOTE:\n        // Returning immediately allows malicious actors to figure out valid emails from response times,\n        // allowing them to only focus on guessing passwords in brute-force attacks.\n        // As a preventive measure, you may want to hash passwords even for invalid emails.\n        // However, valid emails can be already be revealed with the signup page\n        // and a similar timing issue can likely be found in password reset implementation.\n        // It will also be much more resource intensive.\n        // Since protecting against this is non-trivial,\n        // it is crucial your implementation is protected against brute-force attacks with login throttling etc.\n        // If emails/usernames are public, you may outright tell the user that the username is invalid.\n        return new Response(\"Invalid email or password\", {\n            status: 400\n        });\n    }\n\n    const validPassword = await verify(user?.passwordHash as string, password, {\n        memoryCost: 19456,\n        timeCost: 2,\n        outputLen: 32,\n        parallelism: 1\n    });\n    if (!validPassword) {\n        return new Response(\"Invalid email or password\", {\n            status: 400\n        });\n    }\n\n    const session = await lucia.createSession(user.id, {});\n    const sessionCookie = lucia.createSessionCookie(session.id);\n    return new Response(null, {\n        status: 302,\n        headers: {\n            Location: \"/\",\n            \"Set-Cookie\": sessionCookie.serialize()\n        }\n    });\n}",
            "targetSrc": "~/auth/options/password.ts"
          },
          {
            "op": "add-export",
            "targetSrc": "~/auth/options/index.ts",
            "content": "export * from './password'"
          },
          {
            "op": "install",
            "dep": ["zod"]
          }
        ],
        "google": [
          {
            "op": "add",
            "content": "import { Google, generateCodeVerifier, generateState } from \"arctic\";\nimport { serializeCookie, parseCookies } from \"oslo/cookie\"\nimport { db, oauthAccountTable, userTable } from \"~/db\";\nimport { and, eq } from \"drizzle-orm\";\nimport { generateId } from \"lucia\";\nimport { lucia } from \"~/auth\";\n\n\nconst GOOGLE_CLIENT_ID = process.env.GOOGLE_CLIENT_ID;\nconst GOOGLE_CLIENT_SECRET = process.env.GOOGLE_CLIENT_SECRET;\nconst GOOGLE_REDIRECT_URI = process.env.GOOGLE_REDIRECT_URI;\n\nconst google = new Google(GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET, GOOGLE_REDIRECT_URI);\n\nexport async function googleOAuthRedirect(_: Request): Promise<Response> {\n    const state = generateState();\n    const codeVerifier = generateCodeVerifier();\n\n    const url: URL = await google.createAuthorizationURL(state, codeVerifier, {\n        scopes: [\"profile\", \"email\"]\n    });\n\n    const googleOAuthState = serializeCookie('google_oauth_state', state, {\n        path: '/',\n        secure: true,\n        httpOnly: true,\n        maxAge: 600,\n        sameSite: 'lax'\n    })\n\n    const googleCodeVerifier = serializeCookie('google_code_verifier', codeVerifier, {\n        path: '/',\n        secure: true,\n        httpOnly: true,\n        maxAge: 600,\n        sameSite: 'lax'\n    })\n\n    const response = new Response(null, { status: 302, headers: { Location: url.toString() } });\n    response.headers.append(\"Set-Cookie\", googleOAuthState)\n    response.headers.append(\"Set-Cookie\", googleCodeVerifier)\n    return response\n}\n\nexport async function googleOAuthCallback(request: Request) {\n    const url = new URL(request.url)\n    const params = new URLSearchParams(url.searchParams)\n\n    const code = params.get('code')\n    const state = params.get(\"state\");\n\n    const cookies = parseCookies(request.headers.get('cookie'))\n    const storedState = cookies.get('google_oauth_state')\n    const codeVerifier = cookies.get('google_code_verifier')\n\n    if (!code || !state || !storedState || state !== storedState)\n        return new Response(null, { status: 400 });\n\n    try {\n        const tokens = await google.validateAuthorizationCode(code, codeVerifier);\n\n        const response = await fetch('https://openidconnect.googleapis.com/v1/userinfo', { headers: { Authorization: `Bearer ${tokens?.accessToken}` } });\n        const user = await response.json() as { name: string, email: string, sub: string };\n\n        const existingUser = (await db.select().from(oauthAccountTable).where(and(eq(oauthAccountTable.providerId, 'google'), eq(oauthAccountTable.providerUserId, user?.sub))))[0]\n\n        if (existingUser) {\n            const session = await lucia.createSession(existingUser?.userId, {});\n            const sessionCookie = lucia.createSessionCookie(session.id);\n\n            return new Response(null, {\n                status: 302,\n                headers: {\n                    Location: url.toString(),\n                    \"Set-Cookie\": sessionCookie.serialize()\n                }\n            });\n        }\n\n        const userId = generateId(15);\n\n        await db.transaction(async (tx) => {\n            await tx.insert(userTable).values({ id: userId, username: user?.email } as any)\n            await tx.insert(oauthAccountTable).values({ providerId: \"google\", providerUserId: user.sub, userId });\n        })\n\n        const session = await lucia.createSession(userId, {});\n        const sessionCookie = lucia.createSessionCookie(session.id);\n\n        return new Response(null, {\n            status: 302,\n            headers: {\n                Location: url.toString(),\n                \"Set-Cookie\": sessionCookie.serialize()\n            }\n        });\n    } catch (e) {\n        return new Response(null, { status: 500 });\n    }\n}",
            "targetSrc": "~/auth/options/google.ts"
          },
          {
            "op": "add-export",
            "targetSrc": "~/auth/options/index.ts",
            "content": "export * from './google'"
          }
        ],
        "github": [
          {
            "op": "add",
            "content": "import { serializeCookie, parseCookies } from \"oslo/cookie\"\nimport { db, oauthAccountTable, userTable } from \"~/db\";\nimport { GitHub, generateState } from \"arctic\";\nimport { and, eq } from \"drizzle-orm\";\nimport { generateId } from \"lucia\";\nimport { lucia } from \"~/auth\";\n\ninterface GitHubUser {\n    id: string;\n    login: string;\n}\n\nconst GITHUB_CLIENT_ID = process.env.GITHUB_CLIENT_ID as string;\nconst GITHUB_CLIENT_SECRET = process.env.GITHUB_CLIENT_SECRET as string;\n\nconst github = new GitHub(GITHUB_CLIENT_ID, GITHUB_CLIENT_SECRET);\n\nexport async function githubOAuthRedirect(_: Request): Promise<Response> {\n    const state = generateState();\n\n    const url: URL = await github.createAuthorizationURL(state, {\n        scopes: [\"user:email\"]\n    });\n\n    const githubOauthState = serializeCookie('github_oauth_state', state, {\n        path: '/',\n        secure: true,\n        httpOnly: true,\n        maxAge: 600,\n        sameSite: 'lax'\n    })\n\n    const response = new Response(null, { status: 302, headers: { Location: url.toString() } });\n    response.headers.append(\"Set-Cookie\", githubOauthState)\n    return response\n}\n\nexport async function githubOAuthCallback(request: Request) {\n    const url = new URL(request.url)\n    const params = new URLSearchParams(url.searchParams)\n\n    const code = params.get('code')\n    const state = params.get(\"state\");\n\n    const cookies = parseCookies(request.headers.get('cookie'))\n    const storedState = cookies.get('github_oauth_state')\n\n    if (!code || !state || !storedState || state !== storedState)\n        return new Response(null, { status: 400 });\n\n    try {\n        const tokens = await github.validateAuthorizationCode(code);\n        const githubUserResponse = await fetch(\"https://api.github.com/user\", {\n            headers: {\n                Authorization: `Bearer ${tokens.accessToken}`\n            }\n        });\n        const user: GitHubUser = await githubUserResponse.json();\n        const existingUser = (await db.select()\n            .from(oauthAccountTable)\n            .where(\n                and(\n                    eq(oauthAccountTable.providerId, 'github'),\n                    eq(oauthAccountTable.providerUserId, user?.id)\n                )\n            )\n        )[0]\n\n        if (existingUser) {\n            const session = await lucia.createSession(existingUser?.userId, {});\n            const sessionCookie = lucia.createSessionCookie(session.id);\n            return new Response(null, {\n                status: 302,\n                headers: {\n                    Location: url.toString(),\n                    \"Set-Cookie\": sessionCookie.serialize()\n                }\n            });\n        }\n\n        const userId = generateId(15);\n\n        await db.transaction(async (tx) => {\n            await tx.insert(userTable).values({ id: userId, username: user?.login } as any)\n            await tx.insert(oauthAccountTable).values({ providerId: 'github', providerUserId: user.id, userId });\n        })\n\n        const session = await lucia.createSession(userId, {});\n        const sessionCookie = lucia.createSessionCookie(session.id);\n\n        return new Response(null, {\n            status: 302,\n            headers: {\n                Location: url.toString(),\n                \"Set-Cookie\": sessionCookie.serialize()\n            }\n        });\n    } catch (e) {\n        return new Response(null, { status: 500 });\n    }\n}",
            "targetSrc": "~/auth/options/github.ts"
          },
          {
            "op": "add-export",
            "targetSrc": "~/auth/options/index.ts",
            "content": "export * from './github'"
          }
        ],
        "discord": [
          {
            "op": "add",
            "content": "import { serializeCookie, parseCookies } from \"oslo/cookie\"\nimport { db, oauthAccountTable, userTable } from \"~/db\";\nimport { Discord, generateState } from \"arctic\";\nimport { and, eq } from \"drizzle-orm\";\nimport { generateId } from \"lucia\";\nimport { lucia } from \"~/auth\";\n\n\nconst DISCORD_CLIENT_ID = process.env.DISCORD_CLIENT_ID as string;\nconst DISCORD_CLIENT_SECRET = process.env.DISCORD_CLIENT_SECRET as string;\nconst DISCORD_REDIRECT_URL = process.env.DISCORD_REDIRECT_URL as string;\n\nconst discord = new Discord(DISCORD_CLIENT_ID, DISCORD_CLIENT_SECRET, DISCORD_REDIRECT_URL);\n\nexport async function discordOAuthRedirect(_: Request): Promise<Response> {\n    const state = generateState();\n\n    const url: URL = await discord.createAuthorizationURL(state, {\n        scopes: [\"identify\"]\n    });\n    scopes: [\"identify\"]\n\n    const discordOauthState = serializeCookie('discord_oauth_state', state, {\n        path: '/',\n        secure: true,\n        httpOnly: true,\n        maxAge: 600,\n        sameSite: 'lax'\n    })\n\n    const response = new Response(null, { status: 302, headers: { Location: url.toString() } });\n    response.headers.append(\"Set-Cookie\", discordOauthState)\n    return response\n}\n\nexport async function discordOAuthCallback(request: Request) {\n    const url = new URL(request.url)\n    const params = new URLSearchParams(url.searchParams)\n\n    const code = params.get('code')\n    const state = params.get(\"state\");\n\n    const cookies = parseCookies(request.headers.get('cookie'))\n    const storedState = cookies.get('discord_oauth_state')\n\n    if (!code || !state || !storedState || state !== storedState)\n        return new Response(null, { status: 400 });\n\n    try {\n        const tokens = await discord.validateAuthorizationCode(code);\n        const response = await fetch(\"https://discord.com/api/users/@me\", {\n            headers: {\n                Authorization: `Bearer ${tokens.accessToken}`\n            }\n        });\n        const user = await response.json();\n        const existingUser = (await db.select()\n            .from(oauthAccountTable)\n            .where(\n                and(\n                    eq(oauthAccountTable.providerId, 'discord'),\n                    eq(oauthAccountTable.providerUserId, user?.id)\n                )\n            )\n        )[0]\n\n        if (existingUser) {\n            const session = await lucia.createSession(existingUser?.userId, {});\n            const sessionCookie = lucia.createSessionCookie(session.id);\n            return new Response(null, {\n                status: 302,\n                headers: {\n                    Location: url.toString(),\n                    \"Set-Cookie\": sessionCookie.serialize()\n                }\n            });\n        }\n\n        const userId = generateId(15);\n\n        await db.transaction(async (tx) => {\n            await tx.insert(userTable).values({ id: userId, username: user?.login } as any)\n            await tx.insert(oauthAccountTable).values({ providerId: 'discord', providerUserId: user.id, userId });\n        })\n\n        const session = await lucia.createSession(userId, {});\n        const sessionCookie = lucia.createSessionCookie(session.id);\n\n        return new Response(null, {\n            status: 302,\n            headers: {\n                Location: url.toString(),\n                \"Set-Cookie\": sessionCookie.serialize()\n            }\n        });\n    } catch (e) {\n        return new Response(null, { status: 500 });\n    }\n}",
            "targetSrc": "~/auth/options/discord.ts"
          },
          {
            "op": "add-export",
            "targetSrc": "~/auth/options/index.ts",
            "content": "export * from './discord'"
          }
        ]
      }
    }
  ]
}
